# 컴포넌트 패턴 (Component Pattern)

* 모든 코드를 부품화하여 관리

만약 Update 문 안에 모든 기능에 대한 코드를 작성할 경우 디버깅에 어려움이 있으며 의존성에 문제가 생김

ex)
private void Update()
{
    // 이동 기능 코드 전문

    // 애니메이션 전문

    // 물리 적용 전문
}

이 경우 애니메이션 기능에 대한 내용은 다른 함수를 생성해 호출하여 사용하는 것을 지향해야 하며, 다른 기능 또한 마찬가지

----------------------------------------------

## 디자인 요소 1. 객체는 컴포넌트를 어떻게 얻는가?
- 1. 객체가 필요한 컴포넌트를 알아서 생성
- 2. 외부 코드로부터 컴포넌트를 받아옴

유지보수 측면에서는 외부로부터 받는 것이 낫다.

하지만 잘못된 컴포넌트를 넘겨줄 위험성이 존재하기 때문에
객체가 필요한 컴포넌트를 생성하는 선택지 또한 존재한다.

*유연하고 디커플링된 컴포넌트를 구현하고 싶다면 외부로부터 받아옴* 
*객체를 변경하기 어려운 대신 해당 컴포넌트를 보장받고 싶은 경우 직접 생성*

## 디자인 요소 2. 컴포넌트끼리 어떻게 통신할 것인가?
- 1. 컨테이너 객체의 상태를 변경하는 방식
    1. 컴포넌트들은 서로 디커플링 상태 유지
    2. 컴포넌트들이 공유하는 정보를 컨테이너 객체에 전부 넣어야 함
    3. 컴포넌트 실행 순서에 의존하게 됨

- 2. 컴포넌트가 서로 참조하는 방식
    1. 간단하고 빠르다. (public 으로 열어준 모든것을 사용)
    2. 두 컴포넌트가 강하게 결합된다. (커플링이 심해짐)

- 3. 메시지를 전달하는 방식
    * 컨테이너 객체에 간단한 메시징 시스템을 만든 뒤, 각 컴포넌트들이 서로에게 정보를 뿌리게 함
    1. 하위 컴포넌트들은 디커플링.
        * 컴포넌트들은 메세지 값과 커플링 될 뿐.
        * 둘 이상의 객체가 중간 객체를 통해 메세지를 간접적으로 전달해 통신하는 방식을 GoF에서는 중재자(Mediator) 패턴이라고 함.
    2. 컨테이너 객체는 단순. 단순히 메세지만 전달하면 됨.